# 线程池

线程池其实是一种池化技术的实现，池化技术的核心思想其实就是实现资源的可重复利用，让线程在执行完任务不会销毁去继续处理其他的任务，避免资源重复创建和销毁带来的性能开销。还可以提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。。另外，线程池还能起到对线程的管理。

## 1. 线程池的构造

Java 中主要通过构建 `ThreadPoolExecutor` 来创建线程池的。 
`ThreadPoolExecutor` 的主要构造参数有：
1. **corePoolSize**: 核心线程池大小，表示线程池中始终保持运行的线程数量，即使是空闲的，这些线程也会在任务到来时立即响应。
2. **maximumPoolSize**：线程池的最大线程数，表示线程池中能够容纳的最大线程数。当任务较多且所有核心线程都在执行时，线程池会创建新的线程直到达到此值。
3. **keepAliveTime**: 线程的存活时间。当线程池中的线程数量超过 `corePoolSize` 时，多余的空闲线程在等待新任务时的最大等待时间。超过这个时间后会被立即终止。
4. unit：keepAliveTime 的时间单位，如 `TimeUnit.SECONDS` 、`TimeUnit.MILLSECONDS` 等。
5. **workQueue**：任务队列，用于存放等待执行的任务。常见的有 `LinkedBlockingQueue`、`SynchronousQueue` 等，不同的队列类型会影响线程池的行为。
6. **threadFactory**：线程工厂，用于创建线程。可以通过自定义 `ThreadFactory` 来为线程设置名字、优先级等。
7. **handler**：饱和策略（拒绝策略），用于在任务无法执行时采取的策略。当线程池中的线程数达到 `maxiumPoolSize` 且 `workQueue` 已满时，线程池就会拒绝新的任务。

## 2. 线程池的运行原理

刚创建出来的线程池中只有一个构造时传入的阻塞队列，此时里面并没有任何的线程，如果想要在执行之前就创建好核心线程数，可以调用 `prestartAllCoreThreads` 方法来实现，默认是没有任何线程的。

当有线程通过 `execute` 方法提交了一个任务，线程池会首先判断当前线程数是否小于核心线程数，也就是 `corePoolSize`。如果符合小于核心线程数的条件，就会通过 `ThreadFactory` 创建一个线程来执行任务。

当任务执行完之后，线程不会退出，而是会去从阻塞队列中获取任务。

接下来如果又提交了一个任务，会重复上面的步骤。有一点需要注意的是：提交任务的时候，就算有线程池里的线程从阻塞队列中获取不到任务，如果线程池里的线程数还是小于核心线程数，那么依然会继续创建线程，而不是复用现有的线程。

如果线程池中的线程数不再小于核心线程数，此时就会尝试将任务放入阻塞队列中。如果随着任务的增多，队列已经满了，任务放入队列失败就会判断当前线程池中的线程数是否小于最大线程数，也就是 `maximumPoolSize` 参数。如果小于最大线程数，也会创建非核心线程来执行提交的任务。



## 3. 线程池中线程实现复用的原理

## 4. 线程是如何获取任务的以及如何实现超时

## 5. 线程池的5种状态

## 6. 线程池的关闭

## 7. 线程池的监控

## 8. Executors构建线程池以及问题解析

## 9. 线程池的使用场景

## 10. 实际项目中如何合理的自定义线程池