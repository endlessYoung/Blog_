# 实现定时循环

## 方法1：Handler + postDelayed

使用 `Handler` 的 `postDelay(Runnable, delayMillis)` 方法实现定时任务。
该方法适用于需要在主线程或其他线程中处理短时间间隔任务的场景，例如更新UI或轻量级任务。

``` java
Handler handler = new Handler(Looper.getMainLooper());
Runnable runnable = new Runnable() {
  @Override
  public void run() {
    Log.d("HandlerExample", "定时任务")；
    handler.postDelayed(this, 1000);
  }
}

// 开启定时任务
handler.postDelayed(runnable, 1000);

// 停止定时任务
handler.removeCallback(runnable);
```

## 方法2：AlarmManager

## 方法3：JobScheduler

## 方法4：WorkManager

## 方法5：Timer + TimeTask

## 方法6：HandlerThread + Handler

## 方法7：CountDownTimer

## 方法8：ScheduledExecutorService

## 方法9：RxJava + Interval/Timer

## 方法10：kotlin Coroutine + delay

### 总结对比

| 方法                       | 精度  | 适用场景                    | 系统节能 | 易用性  | 备注               |
|----------------------------|-------|-----------------------------|----------|---------|--------------------|
| Handler + `postDelayed`    | 中    | 短时间任务                  | 低       | 高      | 简单任务最佳选择   |
| AlarmManager               | 高    | 唤醒设备的低频任务          | 高       | 中      | 系统资源占用低     |
| JobScheduler               | 低    | 后台任务，考虑约束条件      | 高       | 中      | 适合后台管理任务   |
| WorkManager                | 低    | 后台可靠任务，系统推荐      | 高       | 高      | 最现代化的选择     |
| Timer + TimerTask          | 中    | 轻量循环任务                | 低       | 中      | 不推荐，过时       |
| HandlerThread + Handler    | 中    | 线程独立的定时任务          | 中       | 中      | 传统方式之一       |
| CountDownTimer             | 高    | 倒计时功能                  | 中       | 高      | 简单高效倒计时     |
| ScheduledExecutorService   | 高    | 精确后台任务调度            | 低       | 中      | 高性能需求适用     |
| RxJava + Interval/Timer    | 高    | 响应式编程场景              | 中       | 中      | 现代化需求适用     |
| Kotlin Coroutines + `delay`| 高    | 异步轻量任务                | 中       | 高      | 现代开发优先       |